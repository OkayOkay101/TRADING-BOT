//+------------------------------------------------------------------+
//|                   Moving Average Crossover EA                    |
//|                   Reversed crossover logic                       |
//|                   One trade per crossover                        |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>

CTrade trade;

input int FastMAPeriod = 50;
input int SlowMAPeriod = 200;
input double LotSize = 0.1;

int fastHandle;
int slowHandle;

// Track last bar time to prevent retriggering
datetime lastBarTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization                                             |
//+------------------------------------------------------------------+
int OnInit()
  {
   fastHandle = iMA(NULL, PERIOD_CURRENT, FastMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
   slowHandle = iMA(NULL, PERIOD_CURRENT, SlowMAPeriod, 0, MODE_SMA, PRICE_CLOSE);

   if(fastHandle == INVALID_HANDLE || slowHandle == INVALID_HANDLE)
     {
      Print("Error creating MA handles. Check parameters.");
      return(INIT_FAILED);
     }

   Print("Initialization successful: Fast MA=", FastMAPeriod, ", Slow MA=", SlowMAPeriod);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick()
  {
   // Trade only once per new bar
   datetime currentBarTime = iTime(NULL, PERIOD_CURRENT, 0);
   if(currentBarTime == lastBarTime)
      return; // Still same bar â€” do nothing
   lastBarTime = currentBarTime;

   double fastMA[2], slowMA[2];
   if(CopyBuffer(fastHandle, 0, 0, 2, fastMA) < 2 || CopyBuffer(slowHandle, 0, 0, 2, slowMA) < 2)
     {
      Print("Not enough MA data yet.");
      return;
     }

   bool positionOpen = PositionSelect(Symbol());
   long positionType = -1;
   if(positionOpen)
      positionType = PositionGetInteger(POSITION_TYPE);

   //--- "Bullish" crossover (reversed): Fast MA crosses BELOW Slow MA
   if(fastMA[1] > slowMA[1] && fastMA[0] < slowMA[0])
     {
      Print("Bullish crossover detected (reversed logic).");

      if(!positionOpen)
        {
         trade.Buy(LotSize, Symbol());
        }
      else if(positionType == POSITION_TYPE_SELL)
        {
         trade.PositionClose(Symbol());
         trade.Buy(LotSize, Symbol());
        }
     }

   //--- "Bearish" crossover (reversed): Fast MA crosses ABOVE Slow MA
   else if(fastMA[1] < slowMA[1] && fastMA[0] > slowMA[0])
     {
      Print("Bearish crossover detected (reversed logic).");

      if(!positionOpen)
        {
         trade.Sell(LotSize, Symbol());
        }
      else if(positionType == POSITION_TYPE_BUY)
        {
         trade.PositionClose(Symbol());
         trade.Sell(LotSize, Symbol());
        }
     }
  }
//+------------------------------------------------------------------+
